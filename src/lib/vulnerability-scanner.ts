import { Finding, File } from './database'

export interface VulnerabilityRule {
  id: string
  name: string
  description: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  pattern: RegExp
  fixSuggestion: string
}

// Common vulnerability patterns
const vulnerabilityRules: VulnerabilityRule[] = [
  {
    id: 'sql-injection',
    name: 'SQL Injection',
    description: 'Potential SQL injection vulnerability',
    severity: 'critical',
    pattern: /(?:query|sql|execute)\s*\(\s*[\w$]+\s*\+\s*[\w$]+/gi,
    fixSuggestion: 'Use parameterized queries or prepared statements'
  },
  {
    id: 'xss',
    name: 'Cross-Site Scripting (XSS)',
    description: 'Potential XSS vulnerability',
    severity: 'high',
    pattern: /innerHTML\s*=\s*[\w$]+\s*\+\s*[\w$]+/gi,
    fixSuggestion: 'Use textContent or sanitize input with DOMPurify'
  },
  {
    id: 'hardcoded-secrets',
    name: 'Hardcoded Secrets',
    description: 'Hardcoded API keys, passwords, or tokens',
    severity: 'high',
    pattern: /(?:api_key|password|token|secret)\s*[:=]\s*['"][^'"]{10,}['"]/gi,
    fixSuggestion: 'Move secrets to environment variables'
  },
  {
    id: 'weak-crypto',
    name: 'Weak Cryptography',
    description: 'Use of weak cryptographic algorithms',
    severity: 'high',
    pattern: /(?:md5|sha1)\s*\(/gi,
    fixSuggestion: 'Use SHA-256, bcrypt, or Argon2 for hashing'
  },
  {
    id: 'insecure-random',
    name: 'Insecure Random',
    description: 'Use of Math.random() for security purposes',
    severity: 'medium',
    pattern: /Math\.random\(\)/g,
    fixSuggestion: 'Use crypto.getRandomValues() for cryptographic purposes'
  },
  {
    id: 'eval-usage',
    name: 'Eval Usage',
    description: 'Use of eval() function',
    severity: 'critical',
    pattern: /eval\s*\(/gi,
    fixSuggestion: 'Avoid eval() - use JSON.parse() or other safe alternatives'
  },
  {
    id: 'no-csrf-protection',
    name: 'Missing CSRF Protection',
    description: 'No CSRF token in form submissions',
    severity: 'medium',
    pattern: /<form[^>]*method\s*=\s*['"]post['"][^>]*>/gi,
    fixSuggestion: 'Add CSRF tokens to all POST forms'
  },
  {
    id: 'insecure-headers',
    name: 'Insecure Headers',
    description: 'Missing security headers',
    severity: 'medium',
    pattern: /(?:helmet|security-headers)/gi,
    fixSuggestion: 'Implement security headers using helmet.js'
  }
]

export class VulnerabilityScanner {
  private rules: VulnerabilityRule[]

  constructor(customRules: VulnerabilityRule[] = []) {
    this.rules = [...vulnerabilityRules, ...customRules]
  }

  async scanFile(file: File): Promise<Finding[]> {
    const findings: Finding[] = []
    const lines = file.content.split('\n')

    for (const rule of this.rules) {
      const matches = file.content.match(rule.pattern)
      
      if (matches) {
        for (const match of matches) {
          const lineNumber = this.findLineNumber(file.content, match)
          const codeSnippet = this.extractCodeSnippet(lines, lineNumber)
          
          findings.push({
            id: `${file.id}-${rule.id}-${lineNumber}`,
            project_id: file.project_id,
            file_id: file.id,
            severity: rule.severity,
            message: rule.description,
            code_snippet: codeSnippet,
            line_number: lineNumber,
            created_at: new Date().toISOString()
          })
        }
      }
    }

    return findings
  }

  async scanProject(files: File[]): Promise<Finding[]> {
    const allFindings: Finding[] = []
    
    for (const file of files) {
      const fileFindings = await this.scanFile(file)
      allFindings.push(...fileFindings)
    }

    // Sort by severity (critical -> high -> medium -> low)
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 }
    return allFindings.sort((a, b) => 
      severityOrder[b.severity] - severityOrder[a.severity]
    )
  }

  private findLineNumber(content: string, match: string): number {
    const lines = content.split('\n')
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(match)) {
        return i + 1
      }
    }
    return 1
  }

  private extractCodeSnippet(lines: string[], lineNumber: number): string {
    const start = Math.max(0, lineNumber - 2)
    const end = Math.min(lines.length, lineNumber + 1)
    return lines.slice(start, end).join('\n')
  }

  async generateFix(finding: Finding): Promise<string> {
    const rule = this.rules.find(r => 
      finding.message.includes(r.description) || 
      finding.message.includes(r.name)
    )

    if (rule) {
      return this.applyFixSuggestion(finding.code_snippet, rule)
    }

    return finding.code_snippet // Return original if no fix available
  }

  private applyFixSuggestion(code: string, rule: VulnerabilityRule): string {
    switch (rule.id) {
      case 'sql-injection':
        return code.replace(
          /(query|sql|execute)\s*\(\s*([\w$]+)\s*\+\s*([\w$]+)/gi,
          '$1(`SELECT * FROM table WHERE id = ?`, [$2, $3])'
        )
      
      case 'xss':
        return code.replace(
          /innerHTML\s*=\s*([\w$]+)\s*\+\s*([\w$]+)/gi,
          'textContent = $1 + $2'
        )
      
      case 'hardcoded-secrets':
        return code.replace(
          /(api_key|password|token|secret)\s*[:=]\s*['"][^'"]{10,}['"]/gi,
          '$1: process.env.$1.toUpperCase()'
        )
      
      case 'weak-crypto':
        return code.replace(
          /(md5|sha1)\s*\(/gi,
          'crypto.createHash("sha256").update('
        )
      
      case 'insecure-random':
        return code.replace(
          /Math\.random\(\)/g,
          'crypto.getRandomValues(new Uint32Array(1))[0] / 2**32'
        )
      
      case 'eval-usage':
        return code.replace(
          /eval\s*\(/gi,
          'JSON.parse('
        )
      
      default:
        return code
    }
  }
} 